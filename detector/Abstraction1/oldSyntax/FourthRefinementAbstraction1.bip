// no need for tagger now

model FourthRefinementAbstraction1

  // only one external type: the validity report (generated by the dummy masker)

  // only simple external functions: prints and getters (they are necessary if we deal with an external type)

  port type innerTransition
    
  port type transferRecordDatabase(int replicaIDofTheDetectorOwningTheDB, int replicaID, bool validityReplica)
 
  port type validityReportPort
  
  port type validityReportPortNew(int replicaIDValidityReport, int controllerTimestampValidityReport, int detectorTimestampValidityReport, int healthValidityReport, bool validValidityReport)

  //port type performCheckWithDatabaseAndReports(int result, int replicaIDValidityReport, int controllerTimestampValidityReport, int detectorTimestampValidityReport, int healthValidityReport, bool validValidityReport)

  port type performCheckInsideDatabase

  atomic type Masker(int id) 
    data int replicaID
    
    // validity report fields
    data int replicaIDValidityReport
	data int controllerTimestampValidityReport
	data int detectorTimestampValidityReport
	data int healthValidityReport
	data bool validValidityReport
	
	data int controllerTimestampGenerator
	data int detectorTimestampGenerator
    
    export port validityReportPortNew sendReport(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
    export port validityReportPort generateReport


    place HAVE_A_REPORT_TO_SEND, REPORT_SENT

	// this part can be changed, if we want to perform tests with different reports
    initial to HAVE_A_REPORT_TO_SEND
	do {
		replicaID = id;
		
		controllerTimestampGenerator = 1;
		detectorTimestampGenerator = 1;
		healthValidityReport = 0;
		replicaIDValidityReport = replicaID;
		controllerTimestampValidityReport = controllerTimestampGenerator;
		detectorTimestampValidityReport = detectorTimestampGenerator;
		validValidityReport = false;
		
	//	controllerTimestampGenerator = controllerTimestampGenerator + 1;
	//	detectorTimestampGenerator = detectorTimestampGenerator + 1;
		
	}

    on sendReport from HAVE_A_REPORT_TO_SEND to REPORT_SENT
    on generateReport from REPORT_SENT to HAVE_A_REPORT_TO_SEND
		do {
		
			replicaIDValidityReport = replicaID;
			controllerTimestampValidityReport = controllerTimestampGenerator;
			detectorTimestampValidityReport = detectorTimestampGenerator;
			validValidityReport = false;
			//healthValidityReport = healthValidityReport
			controllerTimestampGenerator = controllerTimestampGenerator + 1;
			detectorTimestampGenerator = detectorTimestampGenerator + 1;
			
		}
  end
  
  atomic type DatabaseReplicas(int id) 
    data int ownerID
    
    data int replicaID1
	data bool validityReplica1
	
	data int replicaID2
	data bool validityReplica2
	
	data int replicaID3
	data bool validityReplica3
	

	// maybe temporary
	// export port performCheckInsideDatabase backToBeginningState

	export port transferRecordDatabase chooseRecord1(ownerID, replicaID1, validityReplica1)
	export port transferRecordDatabase chooseRecord2(ownerID, replicaID2, validityReplica2)
	export port transferRecordDatabase chooseRecord3(ownerID, replicaID3, validityReplica3)
	
	export port transferRecordDatabase update1(ownerID, replicaID1, validityReplica1)
	export port transferRecordDatabase update2(ownerID, replicaID2, validityReplica2)
	export port transferRecordDatabase update3(ownerID, replicaID3, validityReplica3)
	
	export port transferRecordDatabase performCheckDelay1(ownerID, replicaID1, validityReplica1)
	export port transferRecordDatabase performCheckDelay2(ownerID, replicaID2, validityReplica2)
	export port transferRecordDatabase performCheckDelay3(ownerID, replicaID3, validityReplica3)
	
	
	export port performCheckInsideDatabase performCheckCrash
	
	export port performCheckInsideDatabase performCheckDetectors
	
	
	export port performCheckInsideDatabase backToBeginningState

	export port performCheckInsideDatabase init1
	export port performCheckInsideDatabase init2
	export port performCheckInsideDatabase init3

	

	data int maxControllerTS
	data int maxDetectorTS

	// new set of places: some of them will be the same in the detectors
	// this is needed to keep the DB and the detector synchronized
	place START, READY_TO_UPDATE, CHOSEN_RECORD1, CHOSEN_RECORD2, CHOSEN_RECORD3,
	 UPDATE1, UPDATE2, UPDATE3,
	 FINISHED_CHECK_DELAY1, FINISHED_CHECK_DELAY2, FINISHED_CHECK_DELAY3,
	 READY_TO_CHECK, CHECKING_CRASH, CHECKING_DETECTORS,
	CHECKED_DELAY, CHECKED_CRASH, CHECKED_DETECTORS,
	 START_CHECKING_CRASH,
	 START_CHECKING_DETECTORS, DETERMINED_MAX_DETECTOR_TS, LAST_DETECTOR1_CHECKED, LAST_DETECTOR2_CHECKED

	// initialize the database. This part is based on the detector on which the database is located
	
	initial to START
		do {
			replicaID1 = 1; replicaID2 = 2; replicaID3 = 3;
			ownerID = id;
		}
	
	on init1 from START to READY_TO_UPDATE provided (ownerID == 1)
		do {
		//	lastControllerTSReplica1 = 0;
		//	lastDetectorTSReplica1 = 0;
		//	firstControllerTSReplica1 = 0;
		//	healthReplica1 = 127;
			validityReplica1 = true;
		}
	on init2 from START to READY_TO_UPDATE provided (ownerID == 2)
		do {
		//	lastControllerTSReplica2 = 0;
		//	lastDetectorTSReplica2 = 0;
		//	firstControllerTSReplica2 = 0;
		//	healthReplica2 = 127;
			validityReplica2 = true;
		}
	on init3 from START to READY_TO_UPDATE provided (ownerID == 3)
		do {
		//	lastControllerTSReplica3 = 0;
		//	lastDetectorTSReplica3 = 0;
		//	firstControllerTSReplica3 = 0;
		//	healthReplica3 = 127;
			validityReplica3 = true;
		}
		
			
	//	}
	
	// to choose the record to work on
	
	on chooseRecord1 from READY_TO_UPDATE to CHOSEN_RECORD1 //do { printf("Adding the record related to replica 1 to the DB (on the DATABASE %d)\n", ownerID); }
	on chooseRecord2 from READY_TO_UPDATE to CHOSEN_RECORD2 //do { printf("Adding the record related to replica 2 to the DB (on the DATABASE %d)\n", ownerID); }
	on chooseRecord3 from READY_TO_UPDATE to CHOSEN_RECORD3 //do { printf("Adding the record related to replica 3 to the DB (on the DATABASE %d)\n", ownerID); }
	
	// these are the 3 possibilities once a record is chosen. All these paths should lead to the READY_TO_CHECK state
	// in a finite number of steps

	on update1 from CHOSEN_RECORD1 to UPDATE1
	on update2 from CHOSEN_RECORD2 to UPDATE2
	on update3 from CHOSEN_RECORD3 to UPDATE3
	
	on performCheckDelay1 from UPDATE1 to CHECKED_DELAY
	on performCheckDelay2 from UPDATE2 to CHECKED_DELAY
	on performCheckDelay3 from UPDATE3 to CHECKED_DELAY

	on performCheckCrash from CHECKED_DELAY to CHECKED_CRASH
	
	on performCheckDetectors from CHECKED_CRASH to CHECKED_DETECTORS
	
	on backToBeginningState from CHECKED_DETECTORS to READY_TO_UPDATE
  
  end

  atomic type DetectorReplica(int id)
    // variables of the detector
    data int replicaID
    data int detectorTimestamp
    data int detectorHealth
    
    data int checkResultDelay
    data int checkResultCrash
    data int checkResultDetectors
    
    // validity report variables
    data int replicaIDValidityReport
	data int controllerTimestampValidityReport
	data int detectorTimestampValidityReport
	data int healthValidityReport
	data bool validValidityReport
	
	export port validityReportPortNew receiveReportNew(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)

   // export port validityReportPortNew updateDatabaseNew(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)

    export port validityReportPortNew chooseRecord(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
    export port validityReportPortNew update(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
	export port validityReportPortNew performCheckDelay(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
	export port validityReportPortNew performCheckCrash(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
	export port validityReportPortNew performCheckDetectors(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
	export port validityReportPortNew backToBeginningState(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
        
        
    port innerTransition performCheckCrashAndNotifyRebooter
    port innerTransition performCheckDetectorsAndNotifyRebooter
    
   // export port innerTransition backToBeginningState
    port innerTransition backToBeginningStateNotifyRebooter // the type of this port has to be changed!!
        
	//place READY_TO_RECEIVE_REPORT, REPORT_RECEIVED, READY_TO_CHECK, CHECKING_DELAY, CHECKING_CRASH, CHECKING_DETECTORS

	// let's use some common states for the update of the DB: there are some states with the same name as the databases'
	place READY_TO_RECEIVE_REPORT, REPORT_RECEIVED,
	 CHOSEN_RECORD, UPDATED,
	 CHECKING_DELAY, CHECKING_CRASH, CHECKING_DETECTORS


	// the database should initialize itself, on its own
    initial to READY_TO_RECEIVE_REPORT
		do { 	
			replicaID = id;
		}
 // the the data transfer is specified in the connector
 // I have to change the port!
    on receiveReportNew from READY_TO_RECEIVE_REPORT to REPORT_RECEIVED
	
	on chooseRecord from REPORT_RECEIVED to CHOSEN_RECORD
		// these are the 3 possibilities once a record is chosen. All these paths should lead to the READY_TO_CHECK state
	// in a finite number of steps
    
    on update from CHOSEN_RECORD to UPDATED
    
    on performCheckDelay from UPDATED to CHECKING_DELAY
    
    // another connector is needed here
    on performCheckCrash from CHECKING_DELAY to CHECKING_CRASH 

    
    
    on performCheckDetectors from CHECKING_CRASH to CHECKING_DETECTORS 

    
    
    on backToBeginningState from CHECKING_DETECTORS to READY_TO_RECEIVE_REPORT


  end

  connector type BeginUpdateDatabase(transferRecordDatabase chooseRecordOnDatabase, validityReportPortNew chooseRecordOnDetector)
		define chooseRecordOnDatabase chooseRecordOnDetector
		
		on chooseRecordOnDatabase chooseRecordOnDetector provided (chooseRecordOnDatabase.replicaID == chooseRecordOnDetector.replicaIDValidityReport)
		down {
		}
  end 

  connector type TransferValidityReport(validityReportPortNew masker, validityReportPortNew detector1, validityReportPortNew detector2, validityReportPortNew detector3)
    define masker detector1 detector2 detector3

    on masker detector1 detector2 detector3
	down { 
		//detector1.report = masker.report; printReport(detector1.report);
		detector1.replicaIDValidityReport = masker.replicaIDValidityReport;
		detector1.controllerTimestampValidityReport = masker.controllerTimestampValidityReport;
		detector1.detectorTimestampValidityReport = masker.detectorTimestampValidityReport;
		detector1.healthValidityReport = masker.healthValidityReport;
		detector1.validValidityReport = masker.validValidityReport;
		
	//	detector2.report = masker.report; printReport(detector2.report);
		detector2.replicaIDValidityReport = masker.replicaIDValidityReport;
		detector2.controllerTimestampValidityReport = masker.controllerTimestampValidityReport;
		detector2.detectorTimestampValidityReport = masker.detectorTimestampValidityReport;
		detector2.healthValidityReport = masker.healthValidityReport;
		detector2.validValidityReport = masker.validValidityReport;
		
		
	//	detector3.report = masker.report; printReport(detector3.report);
		detector3.replicaIDValidityReport = masker.replicaIDValidityReport;
		detector3.controllerTimestampValidityReport = masker.controllerTimestampValidityReport;
		detector3.detectorTimestampValidityReport = masker.detectorTimestampValidityReport;
		detector3.healthValidityReport = masker.healthValidityReport;
		detector3.validValidityReport = masker.validValidityReport;
		
	}
  end
  
 
  
    connector type PerformCheckCrash(performCheckInsideDatabase performCheckCrashReplica, validityReportPortNew performCheckCrash)
	define performCheckCrashReplica performCheckCrash
	
	on performCheckCrashReplica performCheckCrash
		down {
		}
  end
  
  connector type PerformCheckDetectors(performCheckInsideDatabase performCheckDetectorsReplica, validityReportPortNew performCheckDetectors)
	define performCheckDetectorsReplica performCheckDetectors
	
	on performCheckDetectorsReplica performCheckDetectors
		down {
		}	
  end
  
  connector type BackToBeginningState(performCheckInsideDatabase backToBeginningStateDatabase, innerTransition backToBeginningStateDetector)
	define backToBeginningStateDatabase backToBeginningStateDetector
	
	on backToBeginningStateDatabase backToBeginningStateDetector
		down {
		}	
  end




  connector type Singleton(transferRecordDatabase recordReplica, validityReportPortNew detectorPort)
		define recordReplica detectorPort
		
		on recordReplica detectorPort
			down {
			}
  end
  
  connector type Singleton2(performCheckInsideDatabase recordReplica, validityReportPortNew detectorPort)
		define recordReplica detectorPort
		
		on recordReplica detectorPort
			down {
			}
  end
  
  connector type RealSingleton(performCheckInsideDatabase recordReplica)
		define recordReplica
		
		on recordReplica
			down {
			}
  end
  
  connector type RealSingleton2(validityReportPort recordReplica)
		define recordReplica
		
		on recordReplica
			down {
			}
  end
  

// let's work with 3 detectors
  compound type DetectorsSimulation
    component DetectorReplica dr1(1)
    component DetectorReplica dr2(2)
    component DetectorReplica dr3(3)
    component Masker m1(1)
    
    component DatabaseReplicas db1(1)
    component DatabaseReplicas db2(2)
    component DatabaseReplicas db3(3)
    
    // connectors are needed in order to simulate the reception of a validity report
    // some checks are needed (maybe guards?) in order to enable only the right transitions!
    connector TransferValidityReport fromMaskerToDetectors(m1.sendReport, dr1.receiveReportNew, dr2.receiveReportNew, dr3.receiveReportNew)
  
	// here we don't know what what is the replica described in the validity report
	// this check is performed by the PerformUpdateDatabase connector
    
	connector BeginUpdateDatabase startUpdate11(db1.chooseRecord1, dr1.chooseRecord)
    connector BeginUpdateDatabase startUpdate12(db1.chooseRecord2, dr1.chooseRecord)
    connector BeginUpdateDatabase startUpdate13(db1.chooseRecord3, dr1.chooseRecord)
    
    connector BeginUpdateDatabase startUpdate21(db2.chooseRecord1, dr2.chooseRecord)
    connector BeginUpdateDatabase startUpdate22(db2.chooseRecord2, dr2.chooseRecord)
    connector BeginUpdateDatabase startUpdate23(db2.chooseRecord3, dr2.chooseRecord)
  
	connector BeginUpdateDatabase startUpdate31(db3.chooseRecord1, dr3.chooseRecord)
    connector BeginUpdateDatabase startUpdate32(db3.chooseRecord2, dr3.chooseRecord)
    connector BeginUpdateDatabase startUpdate33(db3.chooseRecord3, dr3.chooseRecord)

    
    connector Singleton update11(db1.update1, dr1.update)
    connector Singleton update12(db1.update2, dr1.update)
    connector Singleton update13(db1.update3, dr1.update)
    
    connector Singleton update21(db2.update1, dr2.update)
    connector Singleton update22(db2.update2, dr2.update)
    connector Singleton update23(db2.update3, dr2.update)
    
    connector Singleton update31(db3.update1, dr3.update)
    connector Singleton update32(db3.update2, dr3.update)
    connector Singleton update33(db3.update3, dr3.update)
    
    
    connector Singleton performCheckDelay11(db1.performCheckDelay1, dr1.performCheckDelay)
    connector Singleton performCheckDelay12(db1.performCheckDelay2, dr1.performCheckDelay)
    connector Singleton performCheckDelay13(db1.performCheckDelay3, dr1.performCheckDelay)
    
    connector Singleton performCheckDelay21(db2.performCheckDelay1, dr2.performCheckDelay)
    connector Singleton performCheckDelay22(db2.performCheckDelay2, dr2.performCheckDelay)
    connector Singleton performCheckDelay23(db2.performCheckDelay3, dr2.performCheckDelay)

    connector Singleton performCheckDelay31(db3.performCheckDelay1, dr3.performCheckDelay)
    connector Singleton performCheckDelay32(db3.performCheckDelay2, dr3.performCheckDelay)
    connector Singleton performCheckDelay33(db3.performCheckDelay3, dr3.performCheckDelay)

    
    connector Singleton2 performCheckCrash11(db1.performCheckCrash, dr1.performCheckCrash)
    
    connector Singleton2 performCheckCrash22(db2.performCheckCrash, dr2.performCheckCrash)
    
    connector Singleton2 performCheckCrash33(db3.performCheckCrash, dr3.performCheckCrash)
    
    
    
    connector Singleton2 performCheckDetectors11(db1.performCheckDetectors, dr1.performCheckDetectors)
    
    connector Singleton2 performCheckDetectors22(db2.performCheckDetectors, dr2.performCheckDetectors)
    
    connector Singleton2 performCheckDetectors33(db3.performCheckDetectors, dr3.performCheckDetectors)
    
    
    connector Singleton2 backToBeginningState11(db1.backToBeginningState, dr1.backToBeginningState)
    connector Singleton2 backToBeginningState22(db2.backToBeginningState, dr2.backToBeginningState)
    connector Singleton2 backToBeginningState33(db3.backToBeginningState, dr3.backToBeginningState)
    
    
    
    connector RealSingleton init11(db1.init1)
    connector RealSingleton init12(db1.init2)
    connector RealSingleton init13(db1.init3)
    
    connector RealSingleton init21(db2.init1)
    connector RealSingleton init22(db2.init2)
    connector RealSingleton init23(db2.init3)
    
    connector RealSingleton init31(db3.init1)
    connector RealSingleton init32(db3.init2)
    connector RealSingleton init33(db3.init3)
    
    connector RealSingleton2 generate(m1.generateReport)
    
  end
  
	component DetectorsSimulation start
end
