// no need for tagger now

// since we are using the abstraction2 of the detector, we assume that the checks are correctly performed

model Detector2Rebooter5
//package Detector2Rebooter5

  // only one external type: the validity report (generated by the dummy masker)

  // only simple external functions: prints and getters (they are necessary if we deal with an external type)

  port type innerTransition
    
  port type transferRecordDatabase(int replicaIDofTheDetectorOwningTheDB, int replicaID, bool validityReplica)
 
  port type validityReportPort
  
  
  port type emptyTransition

  
  port type idTransfer(int faultyReplicaID)
  
  port type validityReportPortNew(int replicaIDValidityReport, int controllerTimestampValidityReport, int detectorTimestampValidityReport, bool validValidityReport)
 // port type validityReportPortNew(int replicaIDValidityReport, int controllerTimestampValidityReport, int detectorTimestampValidityReport, int healthValidityReport, bool validValidityReport)

  //port type performCheckWithDatabaseAndReports(int result, int replicaIDValidityReport, int controllerTimestampValidityReport, int detectorTimestampValidityReport, int healthValidityReport, bool validValidityReport)

  port type performCheckInsideDatabase

  atomic type Masker(int id) 
    data int replicaID
  //  data int one
  //  data int zero
    data int maxConsecutiveFaultyReports
    
    // validity report fields
    data int replicaIDValidityReport
	data int controllerTimestampValidityReport
	data int detectorTimestampValidityReport
//	data int healthValidityReport
	data bool validValidityReport
	
//	data int controllerTimestampGenerator
//	data int detectorTimestampGenerator
    
 //   export port validityReportPortNew sendReport(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
    export port validityReportPortNew sendReport(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)
    export port validityReportPort generateReport


    place HAVE_A_REPORT_TO_SEND, REPORT_SENT

	// this part can be changed, if we want to perform tests with different reports
    initial to HAVE_A_REPORT_TO_SEND
	do {
	
	//	one = 1;
	//	zero = 0;
		replicaID = id;
		maxConsecutiveFaultyReports = 7;
		
	//	controllerTimestampGenerator = 1;
	//	detectorTimestampGenerator = 1;
	//	healthValidityReport = 0;
		replicaIDValidityReport = replicaID;
	//	controllerTimestampValidityReport = controllerTimestampGenerator;
	//	detectorTimestampValidityReport = detectorTimestampGenerator;
		validValidityReport = false;
		
	//	controllerTimestampGenerator = controllerTimestampGenerator + 1;
	//	detectorTimestampGenerator = detectorTimestampGenerator + 1;
		
	}

    on sendReport from HAVE_A_REPORT_TO_SEND to REPORT_SENT
    on generateReport from REPORT_SENT to HAVE_A_REPORT_TO_SEND
		do {
		
			replicaIDValidityReport = replicaID;
		//	controllerTimestampValidityReport = controllerTimestampGenerator;
		//	detectorTimestampValidityReport = detectorTimestampGenerator;
			validValidityReport = false;
			//healthValidityReport = healthValidityReport
		//	controllerTimestampGenerator = controllerTimestampGenerator + 1;
		//	detectorTimestampGenerator = detectorTimestampGenerator + 1;
			
		}
  end
  
  atomic type DatabaseReplicas(int id) 
    data int ownerID
    
    data int consecutiveFaultyReports1
    data int replicaID1
	data bool validityReplica1
	
    data int consecutiveFaultyReports2
	data int replicaID2
	data bool validityReplica2
	
	data int faultyReplicaID // 0: no fault, 1: id of the faulty replica, 2: id of the faulty replica


	// maybe temporary
	// export port performCheckInsideDatabase backToBeginningState

	export port transferRecordDatabase chooseRecord1(ownerID, replicaID1, validityReplica1)
	export port transferRecordDatabase chooseRecord2(ownerID, replicaID2, validityReplica2)
	
	export port transferRecordDatabase update1(ownerID, replicaID1, validityReplica1)
	export port transferRecordDatabase update2(ownerID, replicaID2, validityReplica2)
	
	export port transferRecordDatabase noUpdate1(ownerID, replicaID1, validityReplica1)
	export port transferRecordDatabase noUpdate2(ownerID, replicaID2, validityReplica2)
	


	
	export port transferRecordDatabase performCheckDelay1(ownerID, replicaID1, validityReplica1)
	export port transferRecordDatabase performCheckDelay2(ownerID, replicaID2, validityReplica2)
	
	
	export port performCheckInsideDatabase performCheckCrash
	
	export port performCheckInsideDatabase performCheckDetectors
	
	
	export port performCheckInsideDatabase backToBeginningState

	export port performCheckInsideDatabase init1
	export port performCheckInsideDatabase init2

	
	export port idTransfer backToBeginningStateNotifyRebooterInternal(faultyReplicaID)
	export port idTransfer backToBeginningStateNotifyRebooterExternal(faultyReplicaID)
	

	data int maxControllerTS
	data int maxDetectorTS

	// new set of places: some of them will be the same in the detectors
	// this is needed to keep the DB and the detector synchronized
	place START, READY_TO_UPDATE, CHOSEN_RECORD1, CHOSEN_RECORD2,
	 UPDATE1, UPDATE2, 
	 NOUPDATE1, NOUPDATE2, 
	 FINISHED_CHECK_DELAY1, FINISHED_CHECK_DELAY2, 
	 READY_TO_CHECK, CHECKING_CRASH, CHECKING_DETECTORS,
	CHECKED_DELAY, CHECKED_CRASH, CHECKED_DETECTORS,
	 START_CHECKING_CRASH,
	 START_CHECKING_DETECTORS, DETERMINED_MAX_DETECTOR_TS, LAST_DETECTOR1_CHECKED, LAST_DETECTOR2_CHECKED

	// initialize the database. This part is based on the detector on which the database is located
	
	initial to START
		do {
			replicaID1 = 1; replicaID2 = 2; 
			ownerID = id;
			consecutiveFaultyReports1 = 0;
			consecutiveFaultyReports2 = 0;
			faultyReplicaID = 1;
		}
	
	on init1 from START to READY_TO_UPDATE provided (ownerID == 1)
		do {
		//	lastControllerTSReplica1 = 0;
		//	lastDetectorTSReplica1 = 0;
		//	firstControllerTSReplica1 = 0;
		//	healthReplica1 = 127;
			validityReplica1 = true;
		}
	on init2 from START to READY_TO_UPDATE provided (ownerID == 2)
		do {
		//	lastControllerTSReplica2 = 0;
		//	lastDetectorTSReplica2 = 0;
		//	firstControllerTSReplica2 = 0;
		//	healthReplica2 = 127;
			validityReplica2 = true;
		}

		
			
	//	}
	
	// to choose the record to work on
	
	on chooseRecord1 from READY_TO_UPDATE to CHOSEN_RECORD1 //do { printf("Adding the record related to replica 1 to the DB (on the DATABASE %d)\n", ownerID); }
	on chooseRecord2 from READY_TO_UPDATE to CHOSEN_RECORD2 //do { printf("Adding the record related to replica 2 to the DB (on the DATABASE %d)\n", ownerID); }
	
	// these are the 3 possibilities once a record is chosen. All these paths should lead to the READY_TO_CHECK state
	// in a finite number of steps

	on update1 from CHOSEN_RECORD1 to UPDATE1
	on update2 from CHOSEN_RECORD2 to UPDATE2
	
	
	on noUpdate1 from CHOSEN_RECORD1 to NOUPDATE1
	on noUpdate2 from CHOSEN_RECORD2 to NOUPDATE2
	
	on performCheckDelay1 from NOUPDATE1 to CHECKED_DELAY
	on performCheckDelay2 from NOUPDATE2 to CHECKED_DELAY
	
	on performCheckDelay1 from UPDATE1 to CHECKED_DELAY
	on performCheckDelay2 from UPDATE2 to CHECKED_DELAY

	on performCheckCrash from CHECKED_DELAY to CHECKED_CRASH
	
	on performCheckDetectors from CHECKED_CRASH to CHECKED_DETECTORS
	
	on backToBeginningState from CHECKED_DETECTORS to READY_TO_UPDATE provided(faultyReplicaID==0)
	on backToBeginningStateNotifyRebooterInternal from CHECKED_DETECTORS to READY_TO_UPDATE provided((faultyReplicaID==1 && ownerID==1) || (faultyReplicaID==2 && ownerID==2))
	on backToBeginningStateNotifyRebooterExternal from CHECKED_DETECTORS to READY_TO_UPDATE provided((faultyReplicaID==2 && ownerID==1) || (faultyReplicaID==1 && ownerID==2))
  end

  atomic type DetectorReplica(int id)
    // variables of the detector
    
    data int replicaID
  //  data int detectorTimestamp
  //  data int detectorHealth
    
    data int checkResultDelay
    data int checkResultCrash
    data int checkResultDetectors
    
    // validity report variables
    data int replicaIDValidityReport
	data int controllerTimestampValidityReport
	data int detectorTimestampValidityReport
//	data int healthValidityReport
	data bool validValidityReport
	
//	export port validityReportPortNew receiveReportNew(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
	export port validityReportPortNew receiveReportNew(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)

   // export port validityReportPortNew updateDatabaseNew(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)

//    export port validityReportPortNew chooseRecord(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
 //   export port validityReportPortNew update(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
//	export port validityReportPortNew noUpdate(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
//	export port validityReportPortNew performCheckDelay(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
//	export port validityReportPortNew performCheckCrash(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
//	export port validityReportPortNew performCheckDetectors(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
//	export port validityReportPortNew backToBeginningState(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, healthValidityReport, validValidityReport)
    
    export port validityReportPortNew chooseRecord(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)
	export port validityReportPortNew update(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)
	export port validityReportPortNew noUpdate(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)
	export port validityReportPortNew performCheckDelay(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)
	export port validityReportPortNew performCheckCrash(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)
	export port validityReportPortNew performCheckDetectors(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)
	export port validityReportPortNew backToBeginningState(replicaIDValidityReport, controllerTimestampValidityReport, detectorTimestampValidityReport, validValidityReport)

    
        
        
    port innerTransition performCheckCrashAndNotifyRebooter
    port innerTransition performCheckDetectorsAndNotifyRebooter
    
   // export port innerTransition backToBeginningState
    port innerTransition backToBeginningStateNotifyRebooter // the type of this port has to be changed!!
        
	//place READY_TO_RECEIVE_REPORT, REPORT_RECEIVED, READY_TO_CHECK, CHECKING_DELAY, CHECKING_CRASH, CHECKING_DETECTORS

	// let's use some common states for the update of the DB: there are some states with the same name as the databases'
	place READY_TO_RECEIVE_REPORT, REPORT_RECEIVED,
	 CHOSEN_RECORD, UPDATED, NOUPDATED,
	 CHECKING_DELAY, CHECKING_CRASH, CHECKING_DETECTORS


	// the database should initialize itself, on its own
    initial to READY_TO_RECEIVE_REPORT
		do { 	
			replicaID = id;
			controllerTimestampValidityReport = -1;
			detectorTimestampValidityReport = -1;
		}
 // the the data transfer is specified in the connector
 // I have to change the port!
    on receiveReportNew from READY_TO_RECEIVE_REPORT to REPORT_RECEIVED
	
	on chooseRecord from REPORT_RECEIVED to CHOSEN_RECORD
		// these are the 3 possibilities once a record is chosen. All these paths should lead to the READY_TO_CHECK state
	// in a finite number of steps
    
    on update from CHOSEN_RECORD to UPDATED provided(controllerTimestampValidityReport == 1)
    
    on noUpdate from CHOSEN_RECORD to NOUPDATED provided(controllerTimestampValidityReport == 0)
    
    
    on performCheckDelay from NOUPDATED to CHECKING_DELAY
    
    on performCheckDelay from UPDATED to CHECKING_DELAY
    
    // another connector is needed here
    on performCheckCrash from CHECKING_DELAY to CHECKING_CRASH 

    
    
    on performCheckDetectors from CHECKING_CRASH to CHECKING_DETECTORS 

    
    
    on backToBeginningState from CHECKING_DETECTORS to READY_TO_RECEIVE_REPORT


  end


  atomic type BufferDetectionMessages(int id)
	data int replicaID
	
	data int faultyReplicaID1
	data int faultyReplicaID2
	data int faultyReplicaID3	
	
	data int delivered
	
	export port idTransfer write1(faultyReplicaID1)
	export port idTransfer read1(faultyReplicaID1)
	
	export port idTransfer write2(faultyReplicaID2)
	export port idTransfer read2(faultyReplicaID2)
	
	export port idTransfer write3(faultyReplicaID3)
	export port idTransfer read3(faultyReplicaID3)
		
	place R0_W0_EMPTY, W1_R0, W1_R1, W2_R1, W2_R2, W0_R1, W0_R2, W1_R2, W1_R1_FULL, W0_R0_FULL, W2_R2_FULL, W2_R0
	
	initial to R0_W0_EMPTY
		do {
			replicaID = id;
		}
		
	on write1 from R0_W0_EMPTY to W1_R0
	on write1 from W0_R1 to W1_R1_FULL
	on write1 from W0_R2 to W1_R2
	
	on write2 from W1_R1 to W2_R2
	on write2 from W1_R2 to W2_R2_FULL
	on write2 from W1_R0 to W2_R0
	
	on write3 from W2_R1 to W0_R1
	on write3 from W2_R0 to W0_R0_FULL
	on write3 from W2_R2 to W0_R2
	
	on read1 from W2_R0 to W2_R1
	on read1 from W0_R0_FULL to W0_R1
	on read1 from W1_R0 to W1_R1
	
	on read2 from W2_R1 to W2_R2
	on read2 from W0_R1 to W0_R2
	on read2 from W1_R1_FULL to W1_R2
	
	on read3 from W0_R2 to R0_W0_EMPTY
	on read3 from W1_R2 to W1_R0
	on read3 from W2_R2_FULL to W2_R0
	
  end


  atomic type externalRecoveryHandler(int id)
	data int replicaID
	
	data int faultyReplicaID // it should be diferent from replicaID
	
	export port idTransfer deliver(faultyReplicaID)
	export port idTransfer read(faultyReplicaID)
		
	place START, RECEIVED
	
	initial to START
		do {
			replicaID = id;
		}
		
	on deliver from START to RECEIVED
	on read from RECEIVED to START
  end
  
  
  atomic type Rebooter(int id) 
    data int replicaID
    
    // sent from the detector
    data int faultyReplicaID
	
	//export port emptyTransition transition1
	
	export port idTransfer receive_internal_detection(faultyReplicaID)
	export port emptyTransition send_internal_recovery
	
	export port idTransfer receive_external_detection(faultyReplicaID)
	export port idTransfer send_external_recovery(faultyReplicaID) // to send EXT_REC message to another rebooter
	export port idTransfer receive_ack(faultyReplicaID)
	export port emptyTransition backBeginningState
	
	export port idTransfer receive_detection_message(faultyReplicaID)
	
    place START, RECEIVED_DETECTION_MESSAGE, INT_REC_BEGIN, EXT_REC_BEGIN, EXT_REC_SENT, FINISHED_REC, START_REBOOT

    initial to START
	do {
	
		replicaID = id;
		
	}
	
	on receive_detection_message from START to RECEIVED_DETECTION_MESSAGE
	
	on receive_internal_detection from RECEIVED_DETECTION_MESSAGE to INT_REC_BEGIN provided(replicaID == faultyReplicaID)
	on send_internal_recovery from INT_REC_BEGIN to START

	on receive_external_detection from RECEIVED_DETECTION_MESSAGE to EXT_REC_BEGIN provided(replicaID != faultyReplicaID)
	on send_external_recovery from EXT_REC_BEGIN to EXT_REC_SENT
	on receive_ack from EXT_REC_SENT to FINISHED_REC
	on backBeginningState from FINISHED_REC to START	
  end
  
  



  connector type BeginUpdateDatabase(transferRecordDatabase chooseRecordOnDatabase, validityReportPortNew chooseRecordOnDetector)
		define chooseRecordOnDatabase chooseRecordOnDetector
		
		on chooseRecordOnDatabase chooseRecordOnDetector provided (chooseRecordOnDatabase.replicaID == chooseRecordOnDetector.replicaIDValidityReport)
		down {
		}
  end 

  connector type TransferValidityReport(validityReportPortNew masker, validityReportPortNew detector1, validityReportPortNew detector2)
    define masker detector1 detector2

    on masker detector1 detector2 
	down { 
		//detector1.report = masker.report; printReport(detector1.report);
		detector1.replicaIDValidityReport = masker.replicaIDValidityReport;
		detector1.controllerTimestampValidityReport = masker.controllerTimestampValidityReport;
		detector1.detectorTimestampValidityReport = masker.detectorTimestampValidityReport;
//		detector1.healthValidityReport = masker.healthValidityReport;
		detector1.validValidityReport = masker.validValidityReport;
		
	//	detector2.report = masker.report; printReport(detector2.report);
		detector2.replicaIDValidityReport = masker.replicaIDValidityReport;
		detector2.controllerTimestampValidityReport = masker.controllerTimestampValidityReport;
		detector2.detectorTimestampValidityReport = masker.detectorTimestampValidityReport;
//		detector2.healthValidityReport = masker.healthValidityReport;
		detector2.validValidityReport = masker.validValidityReport;
		
		
	}
  end
  
 
  
  connector type PerformCheckCrash(performCheckInsideDatabase performCheckCrashReplica, validityReportPortNew performCheckCrash)
	define performCheckCrashReplica performCheckCrash
	
	on performCheckCrashReplica performCheckCrash
		down {
		}
  end
  
  connector type PerformCheckDetectors(performCheckInsideDatabase performCheckDetectorsReplica, validityReportPortNew performCheckDetectors)
	define performCheckDetectorsReplica performCheckDetectors
	
	on performCheckDetectorsReplica performCheckDetectors
		down {
		}	
  end
  
  connector type BackToBeginningState(performCheckInsideDatabase backToBeginningStateDatabase, innerTransition backToBeginningStateDetector)
	define backToBeginningStateDatabase backToBeginningStateDetector
	
	on backToBeginningStateDatabase backToBeginningStateDetector
		down {
		}	
  end




  connector type Singleton(transferRecordDatabase recordReplica, validityReportPortNew detectorPort)
		define recordReplica detectorPort
		
		on recordReplica detectorPort
			down {
			}
  end
  
  connector type Singleton2(performCheckInsideDatabase recordReplica, validityReportPortNew detectorPort)
		define recordReplica detectorPort
		
		on recordReplica detectorPort
			down {
			}
  end
  
  connector type RealSingleton(performCheckInsideDatabase recordReplica)
		define recordReplica
		
		on recordReplica
			down {
			}
  end
  
  connector type RealSingleton2(validityReportPort recordReplica)
		define recordReplica
		
		on recordReplica
			down {
			}
  end
  
  connector type RealSingleton3(transferRecordDatabase recordReplica)
		define recordReplica
		
		on recordReplica
			down {
			}
  end
  
// db1.backToBeginningStateNotifyRebooterInternal, dr1.backToBeginningState, buffer1.write1
  connector type BackBeginningStateCommunicationRebooter(idTransfer detectorDBport, validityReportPortNew detectorReplicaPort, idTransfer rebooterPort)
		define detectorDBport detectorReplicaPort rebooterPort
		
		on detectorDBport detectorReplicaPort rebooterPort
			down {
				rebooterPort.faultyReplicaID = detectorDBport.faultyReplicaID;
			}
  end
  
  
  connector type SingletonIdTransfer(idTransfer anyPort)
    define anyPort
    
    on anyPort
		down {
		
		}
  end
  
  connector type emptyTransitionSingleton(emptyTransition anyPort)
    define anyPort
    
    on anyPort
		down {
		
		}
  end
  
  connector type RebooterToRebooter(idTransfer senderPort, idTransfer receiverPort)
	define senderPort receiverPort
	
	on senderPort receiverPort
		down {
			senderPort.faultyReplicaID = receiverPort.faultyReplicaID;
		}
  end
  
  connector type Doubleton (idTransfer senderACK, idTransfer receiverACK)
    define senderACK receiverACK
    
    on senderACK receiverACK
		down {
		
		}
  end
  
  
  connector type DoubletonTransfer(idTransfer detectorPort, idTransfer rebooterPort)
	define detectorPort rebooterPort
	
	on detectorPort rebooterPort
		down {
			rebooterPort.faultyReplicaID = detectorPort.faultyReplicaID;
		}
  end

// let's work with 3 detectors
  compound type DetectorsRebootersSimulation
    component DetectorReplica dr1(1)
    component DetectorReplica dr2(2)
    component Masker m1(1)
    
    component DatabaseReplicas db1(1)
    component DatabaseReplicas db2(2)
    
    component BufferDetectionMessages buffer1(1)
    component BufferDetectionMessages buffer2(2)
    
    component externalRecoveryHandler h1(1)
    component externalRecoveryHandler h2(2)
    
    component Rebooter r1(1)
    component Rebooter r2(2)

    
    // connectors are needed in order to simulate the reception of a validity report
    // some checks are needed (maybe guards?) in order to enable only the right transitions!
    connector TransferValidityReport fromMaskerToDetectors(m1.sendReport, dr1.receiveReportNew, dr2.receiveReportNew)
  
	// here we don't know what what is the replica described in the validity report
	// this check is performed by the PerformUpdateDatabase connector
    
	connector BeginUpdateDatabase startUpdate11(db1.chooseRecord1, dr1.chooseRecord)
    connector BeginUpdateDatabase startUpdate12(db1.chooseRecord2, dr1.chooseRecord)
    
    connector BeginUpdateDatabase startUpdate21(db2.chooseRecord1, dr2.chooseRecord)
    connector BeginUpdateDatabase startUpdate22(db2.chooseRecord2, dr2.chooseRecord)

    
    connector Singleton update11(db1.update1, dr1.update)
    connector Singleton update12(db1.update2, dr1.update)
    
    connector Singleton update21(db2.update1, dr2.update)
    connector Singleton update22(db2.update2, dr2.update)
    
    
    
    connector Singleton noUpdate11(db1.noUpdate1, dr1.noUpdate)
    connector Singleton noUpdate12(db1.noUpdate2, dr1.noUpdate)
    
    connector Singleton noUpdate21(db2.noUpdate1, dr2.noUpdate)
    connector Singleton noUpdate22(db2.noUpdate2, dr2.noUpdate)
    
    
    
    connector Singleton performCheckDelay11(db1.performCheckDelay1, dr1.performCheckDelay)
    connector Singleton performCheckDelay12(db1.performCheckDelay2, dr1.performCheckDelay)
    
    connector Singleton performCheckDelay21(db2.performCheckDelay1, dr2.performCheckDelay)
    connector Singleton performCheckDelay22(db2.performCheckDelay2, dr2.performCheckDelay)
      

    
    connector Singleton2 performCheckCrash11(db1.performCheckCrash, dr1.performCheckCrash)
    
    connector Singleton2 performCheckCrash22(db2.performCheckCrash, dr2.performCheckCrash)
    
    
    
    
    connector Singleton2 performCheckDetectors11(db1.performCheckDetectors, dr1.performCheckDetectors)
    
    connector Singleton2 performCheckDetectors22(db2.performCheckDetectors, dr2.performCheckDetectors)
    
    
    
   // connector Singleton2 backToBeginningState11(db1.backToBeginningState, dr1.backToBeginningState)
   // connector Singleton2 backToBeginningState22(db2.backToBeginningState, dr2.backToBeginningState)
    
    
    connector Singleton2 backToBeginningState11(db1.backToBeginningState, dr1.backToBeginningState)
    connector Singleton2 backToBeginningState22(db2.backToBeginningState, dr2.backToBeginningState)

    // detector1 passing messages to rebooter1
    
    connector BackBeginningStateCommunicationRebooter detectorToBufferInternal11(db1.backToBeginningStateNotifyRebooterInternal, dr1.backToBeginningState, buffer1.write1)
    connector BackBeginningStateCommunicationRebooter detectorToBufferInternal12(db1.backToBeginningStateNotifyRebooterInternal, dr1.backToBeginningState, buffer1.write2)
    connector BackBeginningStateCommunicationRebooter detectorToBufferInternal13(db1.backToBeginningStateNotifyRebooterInternal, dr1.backToBeginningState, buffer1.write3)
    
    connector BackBeginningStateCommunicationRebooter detectorToBufferExternal11(db1.backToBeginningStateNotifyRebooterExternal, dr1.backToBeginningState, buffer1.write1)
    connector BackBeginningStateCommunicationRebooter detectorToBufferExternal12(db1.backToBeginningStateNotifyRebooterExternal, dr1.backToBeginningState, buffer1.write2)
    connector BackBeginningStateCommunicationRebooter detectorToBufferExternal13(db1.backToBeginningStateNotifyRebooterExternal, dr1.backToBeginningState, buffer1.write3)


	connector DoubletonTransfer readFromBuffer11(buffer1.read1, r1.receive_detection_message)
	connector DoubletonTransfer readFromBuffer12(buffer1.read2, r1.receive_detection_message)
	connector DoubletonTransfer readFromBuffer13(buffer1.read3, r1.receive_detection_message)

	connector SingletonIdTransfer detectorToRebooterInternal1(r1.receive_internal_detection)
	connector SingletonIdTransfer detectorToRebooterExternal1(r1.receive_external_detection)

    
    // detector2 passing messages to rebooter2
    connector BackBeginningStateCommunicationRebooter detectorToBufferInternal21(db2.backToBeginningStateNotifyRebooterInternal, dr2.backToBeginningState, buffer2.write1)
    connector BackBeginningStateCommunicationRebooter detectorToBufferInternal22(db2.backToBeginningStateNotifyRebooterInternal, dr2.backToBeginningState, buffer2.write2)
    connector BackBeginningStateCommunicationRebooter detectorToBufferInternal23(db2.backToBeginningStateNotifyRebooterInternal, dr2.backToBeginningState, buffer2.write3)
    
    connector BackBeginningStateCommunicationRebooter detectorToBufferExternal21(db2.backToBeginningStateNotifyRebooterExternal, dr2.backToBeginningState, buffer2.write1)
    connector BackBeginningStateCommunicationRebooter detectorToBufferExternal22(db2.backToBeginningStateNotifyRebooterExternal, dr2.backToBeginningState, buffer2.write2)
    connector BackBeginningStateCommunicationRebooter detectorToBufferExternal23(db2.backToBeginningStateNotifyRebooterExternal, dr2.backToBeginningState, buffer2.write3)


	connector DoubletonTransfer readFromBuffer21(buffer2.read1, r2.receive_detection_message)
	connector DoubletonTransfer readFromBuffer22(buffer2.read2, r2.receive_detection_message)
	connector DoubletonTransfer readFromBuffer23(buffer2.read3, r2.receive_detection_message)
    
	connector SingletonIdTransfer detectorToRebooterInternal2(r2.receive_internal_detection)
	connector SingletonIdTransfer detectorToRebooterExternal2(r2.receive_external_detection)
    
    
    
    connector emptyTransitionSingleton rebooterSendINT_REC1(r1.send_internal_recovery)
    connector emptyTransitionSingleton rebooterSendINT_REC2(r2.send_internal_recovery)

    
    
    connector RebooterToRebooter rebooterSendEXT_REC1(r1.send_external_recovery, h2.deliver) 
    connector RebooterToRebooter rebooterSendEXT_REC2(r2.send_external_recovery, h1.deliver) 

    
  	connector Doubleton rebooterRead_EXT_REC1(r1.receive_ack, h2.read)
	connector Doubleton rebooterRead_EXT_REC2(r2.receive_ack, h1.read)

    
    
    
    connector emptyTransitionSingleton backBeginningRebooter1(r1.backBeginningState)
    connector emptyTransitionSingleton backBeginningRebooter2(r2.backBeginningState)

    
    
    connector RealSingleton init11(db1.init1)
    connector RealSingleton init12(db1.init2)
    
    connector RealSingleton init21(db2.init1)
    connector RealSingleton init22(db2.init2)
    
    
    connector RealSingleton2 generate(m1.generateReport)
    
  end
  
	component DetectorsRebootersSimulation start
end
