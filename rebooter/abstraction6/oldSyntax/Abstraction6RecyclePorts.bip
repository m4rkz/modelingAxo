// no need for tagger now

// now a FIFO version of the buffer.. more meaningful

 model Abstraction6
//package Abstraction6

  // only one external type: the validity report (generated by the dummy masker)

  // only simple external functions: prints and getters (they are necessary if we deal with an external type)
  
  port type emptyTransition
  
  // admitted values for timestampDetection (for both external and internal recoveries):
  // 	- 0: no reboot
  //	- 1: reboot (greater than last reboot + tau reboot)
  // it is generated by the detector, and passed to the receiver
  
  port type idTransfer(int faultyReplicaID, int timestampDetection)

  atomic type Rebooter(int id) 
    data int replicaID
    
    data int timestampDetection
    
    // sent from the detector
    data int faultyReplicaID
	
//	export port emptyTransition transition1
	
	export port idTransfer receive_internal_detection(faultyReplicaID, timestampDetection)
	export port emptyTransition send_internal_recovery
	
	export port idTransfer receive_external_detection(faultyReplicaID, timestampDetection)
	export port idTransfer send_external_recovery(faultyReplicaID, timestampDetection) // to send EXT_REC message to another rebooter
	export port idTransfer receive_ack(faultyReplicaID, timestampDetection)
	export port emptyTransition backBeginningState
	
	export port idTransfer receive_detection_message(faultyReplicaID, timestampDetection)
	
	export port emptyTransition recycle
	export port emptyTransition goReboot
	export port emptyTransition goNoReboot
	
    place START, RECEIVED_DETECTION_MESSAGE, INT_REC_BEGIN, EXT_REC_BEGIN, EXT_REC_SENT, FINISHED_REC, START_REBOOT, REBOOTED, NOT_REBOOTED

    initial to START
	do {
	
		replicaID = id;
		
	}
	
	on receive_detection_message from START to RECEIVED_DETECTION_MESSAGE
	
	on receive_internal_detection from RECEIVED_DETECTION_MESSAGE to INT_REC_BEGIN provided(replicaID == faultyReplicaID)
	// maybe put here the START_REBOOT part? check on the timestampDetection
	on send_internal_recovery from INT_REC_BEGIN to START_REBOOT
	
	on goReboot from START_REBOOT to REBOOTED provided (timestampDetection == 0)
	on goNoReboot from START_REBOOT to NOT_REBOOTED provided (timestampDetection == 1)
	
	on recycle from REBOOTED to START
	on recycle from NOT_REBOOTED to START
	
	
	
	on receive_external_detection from RECEIVED_DETECTION_MESSAGE to EXT_REC_BEGIN provided(replicaID != faultyReplicaID)
	on send_external_recovery from EXT_REC_BEGIN to EXT_REC_SENT
	on receive_ack from EXT_REC_SENT to FINISHED_REC
	on backBeginningState from FINISHED_REC to START	
  end
  
  
  
  atomic type DetectorReplica(int id)
    // variables of the detector
    
    // the detection message should be sent always to the local rebooter
    data int replicaID
       
    data int faultyReplicaID
   // data int replicaIDdestination 
    
    data int timestampDetection
    
	export port emptyTransition detection()
	
	export port idTransfer send_internal_detection(faultyReplicaID, timestampDetection)
	export port idTransfer send_external_detection(faultyReplicaID, timestampDetection)
	
	place START, SENT_INTERNAL, SENT_EXTERNAL
	
	initial to START
		do {
			replicaID = id;
			faultyReplicaID = 1;
			
			timestampDetection = 1; // dummy value, to be randomized
		}

	
	on send_internal_detection from START to SENT_INTERNAL provided(replicaID == faultyReplicaID)
	on send_external_detection from START to SENT_EXTERNAL provided(replicaID != faultyReplicaID)

	on detection from SENT_INTERNAL to START
		do {
			faultyReplicaID = 1;
		}
	on detection from SENT_EXTERNAL to START
		do {
			faultyReplicaID = 1;
		}

  end
  
  atomic type externalRecoveryHandler(int id)
	data int replicaID
	
	data int faultyReplicaID // it should be diferent from replicaID
	data int timestampDetection
	
	export port idTransfer deliver(faultyReplicaID, timestampDetection)
	export port idTransfer read(faultyReplicaID, timestampDetection)
		
	export port emptyTransition recycle
	//export port emptyTransition recycle
	//export port emptyTransition recycle	
	export port emptyTransition goReboot
	export port emptyTransition goNoReboot
		
	place START, RECEIVED, REBOOTED, NOT_REBOOTED, ACK_TO_SEND
	
	initial to START
		do {
			replicaID = id;
		}
		
	on deliver from START to RECEIVED
	
	on goReboot from RECEIVED to REBOOTED provided (timestampDetection == 0)
	on goNoReboot from RECEIVED to NOT_REBOOTED provided (timestampDetection == 1)
	
	on recycle from REBOOTED to ACK_TO_SEND
	on recycle from NOT_REBOOTED to ACK_TO_SEND
	
	// triggers the ACK
	on read from ACK_TO_SEND to START
  end
  
  // a buffer of size 3
  atomic type BufferDetectionMessages(int id)
	data int replicaID
	
	data int faultyReplicaID1
	data int faultyReplicaID2
	data int faultyReplicaID3	
	
	data int timestampDetection1
	data int timestampDetection2
	data int timestampDetection3
	
	data int delivered
	
	export port idTransfer write1(faultyReplicaID1, timestampDetection1)
	export port idTransfer read1(faultyReplicaID1, timestampDetection1)
	
	export port idTransfer write2(faultyReplicaID2, timestampDetection2)
	export port idTransfer read2(faultyReplicaID2, timestampDetection2)
	
	export port idTransfer write3(faultyReplicaID3, timestampDetection3)
	export port idTransfer read3(faultyReplicaID3, timestampDetection3)
		
	place R0_W0_EMPTY, W1_R0, W1_R1, W2_R1, W2_R2, W0_R1, W0_R2, W1_R2, W1_R1_FULL, W0_R0_FULL, W2_R2_FULL, W2_R0
	
	initial to R0_W0_EMPTY
		do {
			replicaID = id;
		}
		
	on write1 from R0_W0_EMPTY to W1_R0
	on write1 from W0_R1 to W1_R1_FULL
	on write1 from W0_R2 to W1_R2
	
	on write2 from W1_R1 to W2_R2
	on write2 from W1_R2 to W2_R2_FULL
	on write2 from W1_R0 to W2_R0
	
	on write3 from W2_R1 to W0_R1
	on write3 from W2_R0 to W0_R0_FULL
	on write3 from W2_R2 to W0_R2
	
	on read1 from W2_R0 to W2_R1
	on read1 from W0_R0_FULL to W0_R1
	on read1 from W1_R0 to W1_R1
	
	on read2 from W2_R1 to W2_R2
	on read2 from W0_R1 to W0_R2
	on read2 from W1_R1_FULL to W1_R2
	
	on read3 from W0_R2 to R0_W0_EMPTY
	on read3 from W1_R2 to W1_R0
	on read3 from W2_R2_FULL to W2_R0
	
  end

  connector type DoubletonTransfer(idTransfer detectorPort, idTransfer rebooterPort)
	define detectorPort rebooterPort
	
	on detectorPort rebooterPort
		down {
			rebooterPort.faultyReplicaID = detectorPort.faultyReplicaID;
			rebooterPort.timestampDetection = detectorPort.timestampDetection;
		}
  end
  
  connector type RebooterToRebooter(idTransfer senderPort, idTransfer receiverPort)
	define senderPort receiverPort
	
	on senderPort receiverPort
		down {
			senderPort.faultyReplicaID = receiverPort.faultyReplicaID;
			senderPort.timestampDetection = receiverPort.timestampDetection;
		}
  end
  
  connector type Singleton(emptyTransition anyPort)
    define anyPort
    
    on anyPort
		down {
		
		}
  end
  
  connector type Singleton2(idTransfer anyPort)
    define anyPort
    
    on anyPort
		down {
		
		}
  end
  
  connector type Doubleton (idTransfer senderACK, idTransfer receiverACK)
    define senderACK receiverACK
    
    on senderACK receiverACK
		down {
		
		}
  end
  
 
  
// let's work with 2 detectors
  compound type RebootersSimulation
    component DetectorReplica d1(1)
    component DetectorReplica d2(2)
    
    component Rebooter r1(1)
    component Rebooter r2(2)
    
    component externalRecoveryHandler h1(1)
    component externalRecoveryHandler h2(2)
    
    component BufferDetectionMessages buffer1(1)
    component BufferDetectionMessages buffer2(2)
    
    // detector1 passing messages to rebooter1
    connector DoubletonTransfer detectorToBufferInternal11(d1.send_internal_detection, buffer1.write1)
    connector DoubletonTransfer detectorToBufferInternal12(d1.send_internal_detection, buffer1.write2)
    connector DoubletonTransfer detectorToBufferInternal13(d1.send_internal_detection, buffer1.write3)
    
    connector DoubletonTransfer detectorToBufferExternal11(d1.send_external_detection, buffer1.write1)
    connector DoubletonTransfer detectorToBufferExternal12(d1.send_external_detection, buffer1.write2)
    connector DoubletonTransfer detectorToBufferExternal13(d1.send_external_detection, buffer1.write3)


	connector DoubletonTransfer readFromBuffer11(buffer1.read1, r1.receive_detection_message)
	connector DoubletonTransfer readFromBuffer12(buffer1.read2, r1.receive_detection_message)
	connector DoubletonTransfer readFromBuffer13(buffer1.read3, r1.receive_detection_message)
    
	connector Singleton2 detectorToRebooterInternal1(r1.receive_internal_detection)
	connector Singleton2 detectorToRebooterExternal1(r1.receive_external_detection)

	// detector2 passing messages to rebooter2
    connector DoubletonTransfer detectorToBufferInternal21(d2.send_internal_detection, buffer2.write1)
    connector DoubletonTransfer detectorToBufferInternal22(d2.send_internal_detection, buffer2.write2)
    connector DoubletonTransfer detectorToBufferInternal23(d2.send_internal_detection, buffer2.write3)
    
    connector DoubletonTransfer detectorToBufferExternal21(d2.send_external_detection, buffer2.write1)
    connector DoubletonTransfer detectorToBufferExternal22(d2.send_external_detection, buffer2.write2)
    connector DoubletonTransfer detectorToBufferExternal23(d2.send_external_detection, buffer2.write3)

	connector DoubletonTransfer readFromBuffer21(buffer2.read1, r2.receive_detection_message)
	connector DoubletonTransfer readFromBuffer22(buffer2.read2, r2.receive_detection_message)
	connector DoubletonTransfer readFromBuffer23(buffer2.read3, r2.receive_detection_message)
    
	connector Singleton2 detectorToRebooterInternal2(r2.receive_internal_detection)
	connector Singleton2 detectorToRebooterExternal2(r2.receive_external_detection)

    
  //  connector DoubletonTransfer detectorToRebooterInternal1(d1.send_internal_detection, r1.receive_internal_detection)
  //  connector DoubletonTransfer detectorToRebooterInternal2(d2.send_internal_detection, r2.receive_internal_detection)
    
  //  connector DoubletonTransfer detectorToRebooterExternal1(d1.send_external_detection, r1.receive_external_detection)
  //  connector DoubletonTransfer detectorToRebooterExternal2(d2.send_external_detection, r2.receive_external_detection)
    
    connector Singleton rebooterSendINT_REC1(r1.send_internal_recovery)
    connector Singleton rebooterSendINT_REC2(r2.send_internal_recovery)
    
    
    connector Singleton reboot_internal1(r1.goReboot)
    connector Singleton no_reboot_internal1(r1.goNoReboot)
    connector Singleton finishInternalRecovery1(r1.recycle)
    
    connector Singleton reboot_internal2(r2.goReboot)
    connector Singleton no_reboot_internal2(r2.goNoReboot)
    connector Singleton finishInternalRecovery2(r2.recycle)
    
    
    // inverted... !!
	connector RebooterToRebooter rebooterSendEXT_REC1(h2.deliver, r1.send_external_recovery) 
    connector RebooterToRebooter rebooterSendEXT_REC2(h1.deliver, r2.send_external_recovery) 
  
	// reboot replica1
	connector Singleton reboot_external1(h2.goReboot)
	connector Singleton no_reboot_external1(h2.goNoReboot)
	connector Singleton finishExternalRecovery1(h2.recycle)
	
	// reboot replica2
	connector Singleton reboot_external2(h1.goReboot)
	connector Singleton no_reboot_external2(h1.goNoReboot)
	connector Singleton finishExternalRecovery2(h1.recycle)
  
  
	connector Doubleton rebooterRead_EXT_REC1(r1.receive_ack, h2.read)
	connector Doubleton rebooterRead_EXT_REC2(r2.receive_ack, h1.read)
    
    // these 2 need to be bounded to the rebooter sending the ACK
    
    connector Singleton backBeginningRebooter1(r1.backBeginningState)
    connector Singleton backBeginningRebooter2(r2.backBeginningState)
    
    connector Singleton backBeginningDetector1(d1.detection)
    connector Singleton backBeginningDetector2(d2.detection)
    
    // RebooterToRebooter also used for the buffer
    
  end
  
	component RebootersSimulation start
end
