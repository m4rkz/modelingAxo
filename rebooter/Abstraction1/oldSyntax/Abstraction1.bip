// no need for tagger now

 model Abstraction1
//package Abstraction1

  // only one external type: the validity report (generated by the dummy masker)

  // only simple external functions: prints and getters (they are necessary if we deal with an external type)
  
  port type emptyTransition
  
  port type idTransfer(int faultyReplicaID)

  atomic type Rebooter(int id) 
    data int replicaID
    
    // sent from the detector
    data int faultyReplicaID
		
	export port idTransfer receive_internal_detection(faultyReplicaID)
	export port emptyTransition send_internal_recovery
	
	export port idTransfer receive_external_detection(faultyReplicaID)
	export port emptyTransition send_external_recovery
	export port emptyTransition receive_ack
	export port emptyTransition backBeginningState

    place START, RECEIVED_DET, INT_REC_BEGIN, EXT_REC_BEGIN, EXT_REC_SENT, FINISHED_REC

    initial to START
	do {
	
		replicaID = id;
		
	}
	
	//on receive_detection from START to RECEIVED_DET
	
	on receive_internal_detection from START to INT_REC_BEGIN
	on send_internal_recovery from INT_REC_BEGIN to START

	on receive_external_detection from START to EXT_REC_BEGIN
	on send_external_recovery from EXT_REC_BEGIN to EXT_REC_SENT
	on receive_ack from EXT_REC_SENT to FINISHED_REC
	on backBeginningState from FINISHED_REC to START
	
	
  end
  
  
  
  atomic type DetectorReplica(int id)
    // variables of the detector
    
    // the detection message should be sent always to the local rebooter
    data int replicaID
    
    
    data int faultyReplicaID
    data int replicaIDdestination 
    
	
	export port emptyTransition detection
	
	export port idTransfer send_internal_detection(faultyReplicaID)
	export port idTransfer send_external_detection(faultyReplicaID)
	
	place START, SENT_INTERNAL, SENT_EXTERNAL
	
	initial to START
		do {
			replicaID = id;
			faultyReplicaID = 1;
		}

	
	on send_internal_detection from START to SENT_INTERNAL provided(replicaID == faultyReplicaID)
	on send_external_detection from START to SENT_EXTERNAL provided(replicaID != faultyReplicaID)

	on detection from SENT_INTERNAL to START
		do {
			faultyReplicaID = 1;
		}
	on detection from SENT_EXTERNAL to START
		do {
			faultyReplicaID = 1;
		}

  end

  connector type DoubletonTransfer(idTransfer rebooterPort, idTransfer detectorPort)
	define detectorPort rebooterPort
	
	on detectorPort rebooterPort
		down {
			rebooterPort.faultyReplicaID = detectorPort.faultyReplicaID;
		}
  end
  
  connector type Singleton(emptyTransition anyPort)
    define anyPort
    
    on anyPort
		down {
		
		}
  end
  
// let's work with 2 detectors
  compound type RebootersSimulation
    component DetectorReplica d1(1)
    component DetectorReplica d2(2)
    
    component Rebooter r1(1)
    component Rebooter r2(2)
    
    
    connector DoubletonTransfer detectorToRebooterInternal1(r1.receive_internal_detection, d1.send_internal_detection)
    connector DoubletonTransfer detectorToRebooterInternal2(r2.receive_internal_detection, d2.send_internal_detection)
    
    connector DoubletonTransfer detectorToRebooterExternal1(r1.receive_external_detection, d1.send_external_detection)
    connector DoubletonTransfer detectorToRebooterExternal2(r2.receive_external_detection, d2.send_external_detection)
    
    connector Singleton rebooterSendINT_REC1(r1.send_internal_recovery)
    connector Singleton rebooterSendINT_REC2(r2.send_internal_recovery)
    
    connector Singleton rebooterSendEXT_REC1(r1.send_external_recovery)
    connector Singleton rebooterSendEXT_REC2(r2.send_external_recovery)
    
    connector Singleton receiveACK1(r1.receive_ack)
    connector Singleton receiveACK2(r2.receive_ack)
    
    connector Singleton backBeginningRebooter1(r1.backBeginningState)
    connector Singleton backBeginningRebooter2(r2.backBeginningState)
    
    connector Singleton backBeginningDetector1(d1.detection)
    connector Singleton backBeginningDetector2(d2.detection)
    
  end
  
	component RebootersSimulation start
end
